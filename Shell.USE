============================================================ sed ============================================================
echo "/a/b/c" | sed 's/\/a\///g'
echo "/a/b/c" | sed 's#/a/##g'
echo "/a/b/c" | sed '/\/a/d'
echo "/a/b/c" | sed '\#/a#d'       #模式分隔符第一个要转义

============================================================ find ============================================================
在当前目录下(包含子目录)，查找所有txt文件并找出含有字符串"bin"的行
find ./ -name "*.txt" -exec grep "bin" {} \;

在当前目录下(包含子目录)，删除所有txt文件
find ./ -name "*.txt" -exec rm {} \;

{}代表的是「由 find 找到的内容」, 「-exec」一直到 「\;」是关键字，代表找到额外动作的开始（-exec）到结束（\），在这中间的就是找到指令内的额外动作
因为「;」在bash的环境下是有特殊意义的，因此利用反斜线来跳脱。

============================================================ exec ============================================================
shell的内建命令exec将并不启动新的shell，而是用要被执行命令替换当前的shell进程，并且将老进程的环境清理掉，而且exec命令后的其它命令将不再执行。
当exec命令来对文件描述符操作的时候，就不会替换shell，而且操作完成后，还会继续执行接下来的命令。 exec 3<&0: 这个命令就是将操作符3也指向标准输入，或说把标准输入保存在3

shell中文件描述符一共有12个:
0  代表标准输入
1  代表标准输出
2  错误输出
其他 3-9 都是空白描述符

exec 3>&1 4>&2 1>>bash.log 2>&1
其含义是：复制标准输出到3，错误输出到4，把3 4保存在bash.log这个文件中

./bash.sh >>bash.log 2>&1
其含义是：将bash.sh脚本执行的标准输出和错误输出追加重定向到bash.log

============================================================ mkfifo ============================================================
由mkfifo创建出来的就是一个命名管道, 例如：mkfifo pipe2, pipe2就是一个命名管道。
可以将输出信道化到不同终端, 例如：
在第一个终端执行: ls > pipe2
在第二个终端执行: cat < pipe2（或cat pipe2, 是取一次。cat < pipe2是持续输入，只要有内容传到pipe2中，就会有内容输出）
pipe2更像是一个临时存储的地方，使用cat pipe2取过内容之后，再执行cat pipe2 ，则不会有显示
exec 6<>/tmp/fifo:   这样就创建了一个文件描述符6，和/tmp/fifo进行了绑定, 操作6就相当于操作/tmp/fifo，并且具有一个新特性，写入不阻塞
# 打开FD6 exec 6>&1
# 关闭FD6 exec 6>&-

============================================================ 变量 ============================================================
()在bash中就代表fork子进程，括号内部的命令将在子进程执行。在子shell里的变量不能被这段子shell外的代码直接访问，也就是说子shell里的变量不能被父shell所存取，实际上它们是局部变量。
父shell变量即使在子shell中进行了修改，但是当返回到父shell对其输出时，它却还是父shell中原来所赋的值。从这里可以看出，子shell可以“感知”父shell中的变量，但它不能修改它。其本质的原因和fork()函数的原理有关。
export 出来的变量不能导出到父进程或者是父进程的环境里。一个自己称可以继承父进程的东西，而不能反过来去影响父进程。

============================================================ 任务 ============================================================
如果要让进程在后台运行，一般情况下，我们在命令后面加上&即可，实际上，这样是将命令放入到一个作业队列中了
$ jobs     //查看任务，返回任务编号n和进程号
$ bg  %n   //将编号为n的任务转后台运行
$ fg  %n   //将编号为n的任务转前台运行
$ ctrl+z   //挂起当前任务
$ ctrl+c   //结束当前任务

============================================================ 变量替换 ============================================================
${var:-string},${var:+string},${var:=string},${var:?string}
① ${var:-string}和${var:=string}:
  若变量var为空，则用在命令行中用string来替换${var:-string}，否则变量var不为空时，则用变量var的值来替换${var:-string}；
  对于${var:=string}的替换规则和${var:-string}是一样的，所不同之处是${var:=string}若var为空时，用string替换${var:=string}的同时，把string赋给变量var： 
  ${var:=string}很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。
② ${var:+string}的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量var的值，即空值(因为变量var此时为空，所以这两种说法是等价的).
③ ${var:?string}替换规则为：若变量var不为空，则用变量var的值来替换${var:?string}；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值.
补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。

============================================================ 模式匹配 ============================================================
模式匹配记忆方法：
# 是去掉左边(在键盘上#在$之左边)
% 是去掉右边(在键盘上%在$之右边)
#和%中的单一符号是最小匹配，两个相同符号是最大匹配。

${var%pattern}, ${var%%pattern}, ${var#pattern}, ${var##pattern}
第一种模式：${variable%pattern}， 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式
第二种模式：${variable%%pattern}，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式
第三种模式：${variable#pattern},  这种模式时，shell在variable中查找，看它是否一给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式
第四种模式：${variable##pattern}, 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式
这四种模式中都不会改变variable的值，其中，只有在pattern中使用了*匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，*表示零个或多个任意字符，?表示仅与一个任意字符匹配，[...]表示匹配中括号里面的字符，[!...]表示不匹配中括号里面的字符。

============================================================ 字符串提取和替换 ============================================================
${var:num}, ${var:num1:num2}, ${var/pattern/pattern}, ${var//pattern/pattern}
第一种模式：${var:num}，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如${var: -2}、${var:1-3}或${var:(-2)}。
第二种模式：${var:num1:num2}，num1是位置，num2是长度。表示从$var字符串的第$num1个位置开始提取长度为$num2的子串。不能为负数。
第三种模式：${var/pattern/pattern}表示将var字符串的第一个匹配的pattern替换为另一个pattern。
第四种模式：${var//pattern/pattern}表示将var字符串中的所有能匹配的pattern替换为另一个pattern。
