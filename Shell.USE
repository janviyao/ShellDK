============================================================ find ============================================================
在当前目录下(包含子目录)，查找所有txt文件并找出含有字符串"bin"的行
find ./ -name "*.txt" -exec grep "bin" {} \;

在当前目录下(包含子目录)，删除所有txt文件
find ./ -name "*.txt" -exec rm {} \;

{}代表的是「由 find 找到的内容」, 「-exec」一直到 「\;」是关键字，代表找到额外动作的开始（-exec）到结束（\），在这中间的就是找到指令内的额外动作
因为「;」在bash的环境下是有特殊意义的，因此利用反斜线来跳脱。

============================================================ exec ============================================================
shell的内建命令exec将并不启动新的shell，而是用要被执行命令替换当前的shell进程，并且将老进程的环境清理掉，而且exec命令后的其它命令将不再执行。
当exec命令来对文件描述符操作的时候，就不会替换shell，而且操作完成后，还会继续执行接下来的命令。 exec 3<&0: 这个命令就是将操作符3也指向标准输入，或说把标准输入保存在3

shell中文件描述符一共有12个:
0  代表标准输入
1  代表标准输出
2  错误输出
其他 3-9 都是空白描述符

exec 3>&1 4>&2 1>>bash.log 2>&1
其含义是：复制标准输出到3，错误输出到4，把3 4保存在bash.log这个文件中

./bash.sh >>bash.log 2>&1
其含义是：将bash.sh脚本执行的标准输出和错误输出追加重定向到bash.log

============================================================ mkfifo ============================================================
由mkfifo创建出来的就是一个命名管道, 例如：mkfifo pipe2, pipe2就是一个命名管道。
可以将输出信道化到不同终端, 例如：
在第一个终端执行: ls > pipe2
在第二个终端执行: cat < pipe2（或cat pipe2, 是取一次。cat < pipe2是持续输入，只要有内容传到pipe2中，就会有内容输出）
pipe2更像是一个临时存储的地方，使用cat pipe2取过内容之后，再执行cat pipe2 ，则不会有显示
exec 6<>/tmp/fifo:   这样就创建了一个文件描述符6，和/tmp/fifo进行了绑定, 操作6就相当于操作/tmp/fifo，并且具有一个新特性，写入不阻塞
# 打开FD6 exec 6>&1
# 关闭FD6 exec 6>&-

============================================================ 变量 ============================================================
()在bash中就代表fork子进程，括号内部的命令将在子进程执行。在子shell里的变量不能被这段子shell外的代码直接访问，也就是说子shell里的变量不能被父shell所存取，实际上它们是局部变量。
父shell变量即使在子shell中进行了修改，但是当返回到父shell对其输出时，它却还是父shell中原来所赋的值。从这里可以看出，子shell可以“感知”父shell中的变量，但它不能修改它。其本质的原因和fork()函数的原理有关。
export 出来的变量不能导出到父进程或者是父进程的环境里。一个自己称可以继承父进程的东西，而不能反过来去影响父进程。

============================================================ 任务 ============================================================
如果要让进程在后台运行，一般情况下，我们在命令后面加上&即可，实际上，这样是将命令放入到一个作业队列中了
$ jobs     //查看任务，返回任务编号n和进程号
$ bg  %n   //将编号为n的任务转后台运行
$ fg  %n   //将编号为n的任务转前台运行
$ ctrl+z   //挂起当前任务
$ ctrl+c   //结束当前任务

